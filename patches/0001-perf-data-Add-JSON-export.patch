From bef58ca8940ca8f1e915f5cf4c8004435129cb6f Mon Sep 17 00:00:00 2001
From: Nicholas Fraser <nfraser@codeweavers.com>
Date: Tue, 16 Mar 2021 14:39:23 -0400
Subject: [PATCH] perf data: Add JSON export

This adds a feature to export perf data to a bespoke JSON file. It uses
a (very) minimal inline JSON encoding, no external dependencies.
Currently it only outputs some sample metadata but it's easily
extensible.

Signed-off-by: Nicholas Fraser <nfraser@codeweavers.com>
---
 tools/perf/Documentation/perf-data.txt |   5 +-
 tools/perf/builtin-data.c              |  35 ++++-
 tools/perf/util/Build                  |   1 +
 tools/perf/util/data-convert-json.c    | 175 +++++++++++++++++++++++++
 tools/perf/util/data-convert-json.h    |   9 ++
 tools/perf/util/data-convert.h         |   2 +
 6 files changed, 219 insertions(+), 8 deletions(-)
 create mode 100644 tools/perf/util/data-convert-json.c
 create mode 100644 tools/perf/util/data-convert-json.h

diff --git a/tools/perf/Documentation/perf-data.txt b/tools/perf/Documentation/perf-data.txt
index 726b9bc9e1a7..417bf17e265c 100644
--- a/tools/perf/Documentation/perf-data.txt
+++ b/tools/perf/Documentation/perf-data.txt
@@ -17,7 +17,7 @@ Data file related processing.
 COMMANDS
 --------
 convert::
-	Converts perf data file into another format (only CTF [1] format is support by now).
+	Converts perf data file into another format.
 	It's possible to set data-convert debug variable to get debug messages from conversion,
 	like:
 	  perf --debug data-convert data convert ...
@@ -27,6 +27,9 @@ OPTIONS for 'convert'
 --to-ctf::
 	Triggers the CTF conversion, specify the path of CTF data directory.
 
+--to-json::
+	Triggers JSON conversion. Specify the JSON filename to output.
+
 --tod::
 	Convert time to wall clock time.
 
diff --git a/tools/perf/builtin-data.c b/tools/perf/builtin-data.c
index 8d23b8d6ee8e..60a47291013f 100644
--- a/tools/perf/builtin-data.c
+++ b/tools/perf/builtin-data.c
@@ -8,6 +8,7 @@
 #include <subcmd/parse-options.h>
 #include "data-convert.h"
 #include "data-convert-bt.h"
+#include "data-convert-json.h"
 
 typedef int (*data_cmd_fn_t)(int argc, const char **argv);
 
@@ -55,7 +56,8 @@ static const char * const data_convert_usage[] = {
 
 static int cmd_data_convert(int argc, const char **argv)
 {
-	const char *to_ctf     = NULL;
+	const char *to_json = NULL;
+	const char *to_ctf = NULL;
 	struct perf_data_convert_opts opts = {
 		.force = false,
 		.all = false,
@@ -63,6 +65,7 @@ static int cmd_data_convert(int argc, const char **argv)
 	const struct option options[] = {
 		OPT_INCR('v', "verbose", &verbose, "be more verbose"),
 		OPT_STRING('i', "input", &input_name, "file", "input file name"),
+		OPT_STRING(0, "to-json", &to_json, NULL, "Convert to JSON format"),
 #ifdef HAVE_LIBBABELTRACE_SUPPORT
 		OPT_STRING(0, "to-ctf", &to_ctf, NULL, "Convert to CTF format"),
 		OPT_BOOLEAN(0, "tod", &opts.tod, "Convert time to wall clock time"),
@@ -72,11 +75,6 @@ static int cmd_data_convert(int argc, const char **argv)
 		OPT_END()
 	};
 
-#ifndef HAVE_LIBBABELTRACE_SUPPORT
-	pr_err("No conversion support compiled in. perf should be compiled with environment variables LIBBABELTRACE=1 and LIBBABELTRACE_DIR=/path/to/libbabeltrace/\n");
-	return -1;
-#endif
-
 	argc = parse_options(argc, argv, options,
 			     data_convert_usage, 0);
 	if (argc) {
@@ -84,11 +82,34 @@ static int cmd_data_convert(int argc, const char **argv)
 		return -1;
 	}
 
+	if (to_json && to_ctf) {
+		pr_err("You cannot specify both --to-ctf and --to-json.");
+		return -1;
+	}
+
+	if (to_json) {
+		if (opts.all) {
+			pr_err("--all is currently unsupported for JSON output.");
+			return -1;
+		}
+		if (opts.tod) {
+			pr_err("--tod is currently unsupported for JSON output.");
+			return -1;
+		}
+		if (opts.force) {
+			pr_err("--force is currently unsupported for JSON output.");
+			return -1;
+		}
+		return bt_convert__perf2json(input_name, to_json, &opts);
+	}
+
 	if (to_ctf) {
 #ifdef HAVE_LIBBABELTRACE_SUPPORT
 		return bt_convert__perf2ctf(input_name, to_ctf, &opts);
 #else
-		pr_err("The libbabeltrace support is not compiled in.\n");
+		pr_err("The libbabeltrace support is not compiled in. perf should be "
+					"compiled with environment variables LIBBABELTRACE=1 and "
+					"LIBBABELTRACE_DIR=/path/to/libbabeltrace/\n");
 		return -1;
 #endif
 	}
diff --git a/tools/perf/util/Build b/tools/perf/util/Build
index e2563d0154eb..de9ac182b25a 100644
--- a/tools/perf/util/Build
+++ b/tools/perf/util/Build
@@ -163,6 +163,7 @@ perf-$(CONFIG_LIBUNWIND_X86)      += libunwind/x86_32.o
 perf-$(CONFIG_LIBUNWIND_AARCH64)  += libunwind/arm64.o
 
 perf-$(CONFIG_LIBBABELTRACE) += data-convert-bt.o
+perf-y += data-convert-json.o
 
 perf-y += scripting-engines/
 
diff --git a/tools/perf/util/data-convert-json.c b/tools/perf/util/data-convert-json.c
new file mode 100644
index 000000000000..42cff9a28729
--- /dev/null
+++ b/tools/perf/util/data-convert-json.c
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * JSON export.
+ *
+ * Copyright (C) 2021, CodeWeavers Inc. <nfraser@codeweavers.com>
+ */
+
+#include "data-convert-json.h"
+
+#include <unistd.h>
+#include <inttypes.h>
+
+#include "linux/compiler.h"
+#include "linux/err.h"
+#include "util/auxtrace.h"
+#include "util/dso.h"
+#include "util/event.h"
+#include "util/evsel.h"
+#include "util/header.h"
+#include "util/map.h"
+#include "util/session.h"
+#include "util/symbol.h"
+#include "util/thread.h"
+#include "util/tool.h"
+
+struct convert_json {
+	struct perf_tool tool;
+	FILE* out;
+	bool first;
+};
+
+static void output_json_string(FILE* out, const char* s) {
+	fputc('"', out);
+	while (*s) {
+		switch (*s) {
+			case '"': fprintf(out, "\\\""); break;
+			case '/': fprintf(out, "\\/"); break;
+			case '\\': fprintf(out, "\\\\"); break;
+			case '\b': fprintf(out, "\\b"); break;
+			case '\f': fprintf(out, "\\f"); break;
+			case '\t': fprintf(out, "\\t"); break;
+			case '\r': fprintf(out, "\\r"); break;
+			case '\n': fprintf(out, "\\n"); break;
+			case '<': fprintf(out, "\\<"); break;
+			case '>': fprintf(out, "\\>"); break;
+			case '&': fprintf(out, "\\&"); break;
+			default: fputc(*s, out); break;
+		}
+		++s;
+	}
+	fputc('"', out);
+}
+
+static void output_json_sample(struct convert_json *c,
+		int64_t timestamp,
+		int pid,
+		int tid,
+		int cpu,
+		const char* symbol,
+		const char* dso,
+		const char* comm)
+{
+	FILE* out = c->out;
+	if (c->first) {
+		c->first = false;
+	} else {
+		fprintf(out, ",");
+	}
+	fprintf(out, "\n\t\t{\n");
+	fprintf(out, "\n\t\t\t\"timestamp\": %" PRIi64 ",", timestamp);
+	fprintf(out, "\n\t\t\t\"pid\": %i,", pid);
+	fprintf(out, "\n\t\t\t\"tid\": %i,", tid);
+	fprintf(out, "\n\t\t\t\"cpu\": %i,", cpu);
+	fprintf(out, "\n\t\t\t\"symbol\": ");
+	output_json_string(out, symbol);
+	fprintf(out, ",\n\t\t\t\"comm\": ");
+	output_json_string(out, comm);
+	fprintf(out, ",\n\t\t\t\"dso\": ");
+	output_json_string(out, dso);
+	fprintf(out, "\n\t\t}");
+}
+
+static int process_sample_event(struct perf_tool *tool,
+				union perf_event *event __maybe_unused,
+				struct perf_sample *sample,
+				struct evsel *evsel __maybe_unused,
+				struct machine *machine)
+{
+	struct convert_json *c = container_of(tool, struct convert_json, tool);
+	const char* symbol_name;
+	const char* dso_name;
+	int cpu;
+	struct addr_location al;
+
+	if (machine__resolve(machine, &al, sample) < 0) {
+		return 0;
+	}
+
+	if (al.sym == NULL) {
+		return 0;
+	}
+
+	symbol_name = al.sym->name;
+	dso_name = al.map->dso->short_name;
+	cpu = al.thread->cpu;
+
+	output_json_sample(c,
+			sample->time,
+			al.thread->pid_,
+			al.thread->tid,
+			cpu,
+			symbol_name,
+			dso_name,
+			thread__comm_str(al.thread));
+
+	return 0;
+}
+
+int bt_convert__perf2json(const char *input_name, const char *output_name,
+			 struct perf_data_convert_opts *opts __maybe_unused)
+{
+	struct perf_session *session;
+
+	struct convert_json c = {
+		.tool = {
+			.sample = process_sample_event,
+			.mmap = perf_event__process_mmap,
+			.mmap2 = perf_event__process_mmap2,
+			.comm = perf_event__process_comm,
+			.namespaces = perf_event__process_namespaces,
+			.cgroup = perf_event__process_cgroup,
+			.exit = perf_event__process_exit,
+			.fork = perf_event__process_fork,
+			.lost = perf_event__process_lost,
+			.tracing_data = perf_event__process_tracing_data,
+			.build_id = perf_event__process_build_id,
+			.id_index = perf_event__process_id_index,
+			.auxtrace_info = perf_event__process_auxtrace_info,
+			.auxtrace = perf_event__process_auxtrace,
+			.event_update = perf_event__process_event_update,
+			.ordered_events = true,
+			.ordering_requires_timestamps = true,
+		},
+		.first = true,
+	};
+
+	struct perf_data data = {
+		.mode = PERF_DATA_MODE_READ,
+		.path = input_name,
+	};
+
+	c.out = fopen(output_name, "w");
+	if (!c.out) {
+		printf("error opening output file!\n");
+		return -1;
+	}
+
+	session = perf_session__new(&data, false, &c.tool);
+	if (IS_ERR(session)) {
+		printf("error creating perf session!\n");
+		return -1;
+	}
+
+	if (symbol__init(&session->header.env) < 0) {
+		printf("symbol init error!\n");
+		return -1;
+	}
+
+	fprintf(c.out, "{\n\t\"perf-json-version\": 1,");
+	fprintf(c.out, "\n\t\"samples\": [");
+	perf_session__process_events(session);
+	fprintf(c.out, "\n\t]\n}\n");
+
+	return 0;
+}
diff --git a/tools/perf/util/data-convert-json.h b/tools/perf/util/data-convert-json.h
new file mode 100644
index 000000000000..1fcac5ce3ec1
--- /dev/null
+++ b/tools/perf/util/data-convert-json.h
@@ -0,0 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __DATA_CONVERT_JSON_H
+#define __DATA_CONVERT_JSON_H
+#include "data-convert.h"
+
+int bt_convert__perf2json(const char *input_name, const char *to_ctf,
+			 struct perf_data_convert_opts *opts);
+
+#endif /* __DATA_CONVERT_JSON_H */
diff --git a/tools/perf/util/data-convert.h b/tools/perf/util/data-convert.h
index feab5f114e37..17c35eb6ab4f 100644
--- a/tools/perf/util/data-convert.h
+++ b/tools/perf/util/data-convert.h
@@ -2,6 +2,8 @@
 #ifndef __DATA_CONVERT_H
 #define __DATA_CONVERT_H
 
+#include <stdbool.h>
+
 struct perf_data_convert_opts {
 	bool force;
 	bool all;
-- 
2.30.1

